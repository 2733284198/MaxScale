#
# This file contains statements qc_sqlite is known not to parse.
#

(SELECT a, b AS c FROM t1) ORDER BY c+1;
# Problem: SELECT in parenthesis.

SELECT 1 FROM t2 WHERE pk > ANY (SELECT 1 FROM t2);
# Problem: The second SELECT.

SELECT table3 .`date_key` field1
  FROM
    B table1 LEFT JOIN B table3 JOIN
      (BB table6 JOIN A table7 ON table6 .`varchar_nokey`)
       ON table6 .`int_nokey` ON table6 .`date_key`
  WHERE  NOT ( table1 .`varchar_key`  AND table7 .`pk`) GROUP  BY field1;
# Problem: Fails to parse some ON.

SET @x:= (SELECT h FROM t1 WHERE (a,b,c,d,e,f,g)=(1,2,3,4,5,6,7));
# REMOVE: expr(A) ::= LP(B) expr(X) RP(E). {A.pExpr = X.pExpr; spanSet(&A,&B,&E);}
# REMOVE: expr(A) ::= LP expr(X) COMMA(OP) expr(Y) RP. {spanBinaryExpr(&A,pParse,@OP,&X,&Y);}
# ADD   : expr(A) ::= LP exprlist RP. { ... }

insert into t1 values (2, 2) on duplicate key update data= data + 10;
# Problem: warning: [qc_sqlite] Statement was only partially parsed (Sqlite3 error: SQL logic error
#          or missing database, near "on": syntax error): "insert into t1 values (2, 2) on duplicate
#          key update data= data + 10;"

SET @`a b`='hello';
set @`test`=1;
set @"tEST"=3;
set @`TeST`=4;
# warning: qc_sqlite: Statement was classified only based on keywords
# (Sqlite3 error: SQL logic error or missing database, unrecognized token: "@"): "set @=4"
#
# sqlite3GetToken needs to be modified to accept a quoted variable name.

SAVEPOINT sa_savepoint_1
#warning: [qc_sqlite] Statement was neither parsed nor recognized from keywords
# (Sqlite3 error: SQL logic error or missing database, near "SNAPSHOT": syntax error): "SNAPSHOT s"

RELEASE SAVEPOINT sa_savepoint_1
# warning: [qc_sqlite] Statement was neither parsed nor recognized from keywords
# (Sqlite3 error: SQL logic error or missing database, near "RELEASE": syntax error): "RELEASE SNAPSHOT s"

INSERT INTO t1 ( a ) SELECT 0 ON DUPLICATE KEY UPDATE a = a + VALUES (a);
# warning: [qc_sqlite] Statement was only partially parsed
# (Sqlite3 error: SQL logic error or missing database, near "ON": syntax error):
# "INSERT INTO t1 ( a ) SELECT 0 ON DUPLICATE KEY UPDATE a = a + VALUES (a)"

PREPARE stmt FROM 'UPDATE t2 AS A NATURAL JOIN v1 B SET B.f1 = 1';
# warning: [qc_sqlite] Statement was classified only based on keywords
# (Sqlite3 error: SQL logic error or missing database, near "SET": syntax error):
# "UPDATE t2 AS A NATURAL JOIN v1 B SET B.f1 = 1"

SELECT LENGTH(_utf8 0xC39F), LENGTH(CHAR(14844588 USING utf8));
# warning: [qc_sqlite] Statement was classified only based on keywords
# (Sqlite3 error: SQL logic error or missing database, near "0xC39F": syntax error):
# "SELECT LENGTH(_utf8 0xC39F), LENGTH(CHAR(14844588 USING utf8));"

SELECT t.f FROM d.t;
# qc_get_field_info        : ERR: d.t.f(QC_USED_IN_SELECT) != t.f(QC_USED_IN_SELECT)
# Table names need to be collected in a more intelligent fashion to be able
# to do that.
select t.c,t1.b from t,mysqltest.t1 where t.c=t1.a;
with t as (select c from mysqltest.t2 where c < 2) select t.c,t1.b from t,mysqltest.t1 where t.c=t1.a;

#MXS qc_mysqlembedded and qc_sqlite disagree in the used fields.
#MXS Both return correctly the folks fields (i.e. the real ones),
#MXS but disagree on the fields of the CTR tables.
#
with recursive
ancestor_couples(h_id, h_name, h_dob, h_father, h_mother,
                 w_id, w_name, w_dob, w_father, w_mother)
as
(
  select h.*, w.*
    from folks h, folks w,  coupled_ancestors a
      where a.father = h.id AND a.mother = w.id
  union 
  select h.*, w.*
    from folks v, folks h, folks w
      where v.name = 'Me' and
            (v.father = h.id AND v.mother= w.id)
),
coupled_ancestors (id, name, dob, father, mother)
as
(
  select h_id, h_name, h_dob, h_father, h_mother
    from ancestor_couples
  union all
  select w_id, w_name, w_dob, w_father, w_mother
    from ancestor_couples
)
select h_name, h_dob, w_name, w_dob
  from ancestor_couples;

#MXS qc_sqlite cannot parse this
#MXS qc_parse                 : INF: QC_QUERY_PARSED != QC_QUERY_TOKENIZED
set statement standard_compliant_cte=0 for select 1;

#MXS qc_sqlite cannot parse this
#MXS qc_parse                 : INF: QC_QUERY_PARSED != QC_QUERY_PARTIALLY_PARSED
create table my_ancestors
(
with recursive
ancestor_ids (id)
as
(
  select father from folks where name = 'Me'
  union
  select mother from folks where name = 'Me'
  union
  select father from folks, ancestor_ids a  where folks.id = a.id
  union
  select mother from folks, ancestor_ids a  where folks.id = a.id
)
select p.* from folks as p, ancestor_ids as a where p.id = a.id
);

#MXS qc_sqlite cannot parse this
#MXS qc_parse                 : INF: QC_QUERY_PARSED != QC_QUERY_INVALID
analyze format=json 
with recursive src(counter) as 
(select 1 
 union 
 select counter+1 from src where counter<10
) select * from src;

#MXS qc_sqlite
#MXS Statement was classified only based on keywords (Sqlite3 error: SQL logic
#MXS error or missing database, near "(": syntax error): "create view win_view
#MXS as (select a, min(a) over () from t1 where a = 1);"
create view win_view
as (select a, min(a) over () from t1 where a = 1);
select * from win_view;
